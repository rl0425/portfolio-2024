
# 내 포트폴리오 관련
Experienced Frontend Developer with Full-Stack Expertise
일단 내가 가진 기술스택이랑 경력을 애기하자면, 이것도 컨벤션에 적어줬으면 좋겠거든? 난 1년 반 동안 프론트엔드에서 자바스크립트, 노드, 익스프레스, 몽고디비 정도를 처음 회사에서 사용하고 배웠고, 이 기간에는 거의 순수 자바스크립트등 기초적인 프론트엔드의 기술들을 다뤘어. 어떤걸 개발했냐면, 프로젝트 관리 매니저 툴이 뭔지 알지? ppm 말이야. 그걸 만드는 회사였고, 난 그 회사에서 프로젝트 관리를 위한 여러가지 툴을 만들었는데, 가장 대표적인건 간트차트를 만든거야. 그리고 프로젝트에 대한 개요, 평가, 생성 등의 기능과 함께, 엔터프라이즈 전용 기능, 개발을 위한 각 공통화 문서들을 작성하고 배포한 경험이 있어. 그리고 최근 1년동안은, 강의 사이트가 주요사업인 회사에서 일을 했는데, 여긴 누적학생수도 170만이고 선생도 몇백명 정도고 매출도 년단위로 200억 정도(최근)에 나오는 실적은 괜찮은 회사야. 여기에서 나는 프론트엔드의 역할을 했는데, 기술 스택으로는 리액트, 타입스크립트, next, tailwind, materials-ui, recoil, redux, 정도를 사용했어. 실제로 작업한 프로젝트는 이 강의 사이트에서 학생들을 위한 zoom과 같은 화상 통화 서비스를 개발했어. 이 화상 서비스는, 여러가지 라이브러리를 결제하고 한 곳에 뭉쳐서 개발했고, 현재 성공적으로 사용되고 있어. 사용한 라이브러리는 일단 화상 서비스 시스템인 agora를 적극 차용했고, react, next, typescript를 사용해서 개발했어. 이 서비스에만 1년 정도가 걸린것 같아. 이게 내가 지금까지 해온 프로젝트 및 회사생활의 경력이야. 이걸 컨벤션으로 삼아줬으면 좋겠어
INTRODUCE.
2년 반 차 프론트엔드 개발자로서, 기술적 발전과 비즈니스 성과를 동시에 창출하는 것을 목표로 합니다.
첫 직장에서는 프로젝트 관리 도구(PPM)의 핵심 기능인 간트차트 (Gantt Chart), 프로젝트 생성 및 관리에 필요한 모든 페이지를 직접 설계 및 구현하거나 직접적인 도움을 제공하여 100억 원 규모의 투자 유치와 140개 이상의 고객사 확보에 기여했습니다. 이를 통해 기술 개발이 비즈니스 성과로 이어질 수 있음을 체감하며, 실질적 가치를 창출하는 개발자의 중요성을 배웠습니다.
이후, 두 번째 회사에서는 누적 학생 수 170만 명, 연 매출 200억 원 규모의 온라인 교육 플랫폼에서 실시간 화상 통화 서비스를 주도적으로 개발했습니다. 특정 라이브러리(Agora)를 효과적으로 활용해 수백 개 강의와 강사를 지원하는 플랫폼의 대표 기능으로 자리 잡았으며, 이를 통해 플랫폼 사용자 경험과 비즈니스 경쟁력을 크게 향상시켰습니다.

코드 품질 개선과 개발 프로세스 최적화를 중요하게 여기며, 사용자 중심의 생산적인 서비스 개발을 추구합니다.
또한, 기존 기술 스택과 요구사항을 충실히 준수하면서도 최신 기술 트렌드에 뒤처지지 않는 개발 철학을 가지고 있습니다.
팀 단위 협업의 중요성을 깊이 생각하며, 다양한 직무의 팀원들과 적극적으로 소통하고 협력하여 높은 완성도의 결과물을 만들어내는 것을 목표로 삼고 있습니다.

WORK EXPERIENCE.
(주)헤븐트리
2021년 7월 ~ 2022년 12월

프로젝트 관리 솔루션에서 포트폴리오까지 통합적인 관리를 할 수 있는 프로그램 클로바인(Clovine)을 개발하는 IT 솔루션 기업

프론트엔드/백엔드 개발
Clovine의 통합형 프로젝트 관리 프로그램(PPM) 개발
• DHTMLX 라이브러리 기반의 간트차트를 커스터마이징하여 태스크, 마일스톤, 일정 그래픽 차트 및 실시간 수정 기능을 성공적으로 개발, 사용자 경험을 개선
• 프로젝트 생성, 작업 등록/관리, 팀원 할당, 진척도 추적 등 핵심 PPM 기능을 구현하여 API 통신 속도를 300% 향상시키고 시스템 반응성을 극대화
• 프로젝트 개요, 평가, 생성 페이지의 설계 및 구현을 통해 웹페이지 방문자 수(PV)를 200% 증가시켜 비즈니스 성과를 창출
• 엔터프라이즈 고객을 위한 트리 뷰 조직도, 워크스페이스 간트차트, 사업 분야 리스트 등 맞춤형 기능을 개발하여 고객 만족도를 높임
개발 프로세스 최적화 및 문서화
• 데이터베이스 테이블 정의서 및 함수 기능 명세서를 작성하여 유지보수성을 향상시키고, 팀 내 지식 공유를 촉진
• 프로젝트 관리 및 협업을 위한 공통 컴포넌트와 UI 가이드라인을 문서화하여 개발 표준을 수립
• Git 브랜치 전략을 수립하고 코드 리뷰 프로세스를 구축하여 팀 협업의 효율성을 40% 증가
성과 및 기여
• 해당 프로젝트를 통해 100억 원 규모의 투자 유치 및 140개 이상의 고객사 확보에 기여하여 회사의 성장 발판 마련
• PM을 맡은 프로젝트에서 창업진흥원 소속 다수 기업의 접근성과 실사용률을 확보하여 실질적인 비즈니스 성과를 달성
• 함수 모듈화와 재사용 가능한 컴포넌트 설계를 통해 개발 생산성을 향상시키고, 유지보수성을 강화하여 팀의 작업 효율성을 극대화
정기적인 사용자 피드백 세션을 통해 제품 개선 방향성을 도출하고, 이를 기반으로 한 기능 업데이트로 고객의 요구를 반영
(주)클래스유
2023년 8월 ~ 2024년 11월

강의별 커뮤니티 서비스가 있는 커뮤니티형 온라인 강의 플랫폼을 개발 및 지원하는 IT 솔루션 기업

프론트엔드 개발
실시간 강의 및 화상 통화 서비스 개발
• Agora Video SDK와 SD-RTN을 활용하여 실시간 강의 및 화상 통화 서비스의 핵심 기능을 구현하여 사용자 경험을 극대화
• 수십 명의 학생과 강사가 동시 접속할 수 있는 대규모 실시간 강의 시스템을 성공적으로 구축하여 플랫폼의 확장성을 확보
• 지연 로딩 및 컴포넌트 최적화를 통해 초기 로딩 속도를 30% 향상시키고, 대규모 사용자 접속 시 안정성을 극대화
• 화면 공유, 강의 영상 재생, 실시간 채팅, 소그룹 라이브 등 다양한 인터랙티브 기능을 개발하여 사용자 참여도를 향상
개발 프로세스 개선
• Webpack 빌드 최적화 및 코드 스플리팅 기법을 통해 초기 로딩 시간을 50% 단축
• TypeScript 도입 및 코드 품질 개선을 위한 컨벤션을 수립하고, 재사용 가능한 UI 컴포넌트 라이브러리를 구축하여 개발 효율성을 증가
• TypeScript와 Next.js를 기반으로 프로젝트 구조를 재설계하고, 코드 마이그레이션을 주도하여 코드의 일관성을 확보
• Recoil/Redux 기반의 전역 상태 관리 아키텍처를 설계하고 성능을 최적화하여 애플리케이션의 반응성을 개선
플랫폼 유지 및 개선
• Context API와 React Query를 활용하여 전역 상태 관리 구조를 개선하고 비동기 로직 처리를 위한 커스텀 훅을 설계 및 적용하여 코드의 가독성을 높임
• TypeScript 도입 및 코드 컨벤션 정립으로 코드 품질 및 유지보수성을 강화하여 팀 내 협업을 원활하게 함
• 반응형 UI/UX 개선을 통해 다양한 디바이스에서 사용자 경험을 향상시켜 사용자 만족도를 높임
• 사용자 피드백 수집 및 분석을 통해 기능 개선 사항을 도출하고, 이를 바탕으로 지속적인 플랫폼 개선을 주도
성과 및 기여
• 실시간 강의 시스템 구축으로 월간 활성 사용자(MAU) 50% 증가를 달성하여 플랫폼의 가치 증대에 기여
• 화상 통화 기능 도입에 따른 사용자 체류 시간 평균 45% 향상을 이끌어내어 사용자 참여도를 높임
• 소그룹 라이브 기능 개발로 학습자 참여도를 15% 증가시켜 교육 효과를 극대화
• 모바일 최적화를 통한 크로스 플랫폼 지원으로 모바일 사용자 비율을 확대하여 시장 경쟁력을 강화
• 팀 내 코드 리뷰 및 지식 공유를 통해 팀원들의 기술 역량을 강화하고, 프로젝트의 전반적인 품질을 향상시킴
멘토링
2024년 8월 ~ 2024년 9월

[유데미 x 스나이퍼팩토리] Next.js 프로젝트 캠프 2기 리드 멘토

프론트엔드 개발
주요 역할 및 성과
• Next.js 기반의 실전 프로젝트 캠프에서 3개 팀을 동시에 리드하며 멘토링을 수행, 각 팀의 프로젝트 진행 상황을 주도적으로 관리
• 팀별 프로젝트 기획부터 배포까지의 과정을 기술적으로 지도하여 실무 경험을 쌓도록 지원
• 총 12명의 교육생 중 1명의 우수 수료생을 배출하여 프로그램의 효과성을 입증
프로젝트 기획 및 설계
• 요구사항 분석 및 기술 스택 선정에 대한 멘토링을 통해 팀들이 프로젝트 목표에 적합한 기술을 선택하도록 유도
• 프로젝트 아키텍처 설계를 멘토링하여 각 팀의 설계가 최적화될 수 있도록 지원
• Git 기반의 협업 워크플로우를 구축하여 팀 내 협업 효율성을 극대화하고 코드 관리 체계를 정립
기술 지도
• Next.js 13 App Router를 실전에서 활용할 수 있도록 실습을 통해 심화 교육 제공
• TypeScript 기반의 컴포넌트 설계를 지도하여 코드의 가독성과 유지보수성을 높임
• 상태 관리 및 데이터 페칭 전략을 수립하여 팀들이 효율적으로 데이터를 처리할 수 있도록 지원
• CI/CD 파이프라인 구축을 지원하여 자동화된 배포 프로세스를 도입, 개발 주기를 단축
프로젝트 관리
• 주간 코드 리뷰를 진행하여 코드 품질을 높이고, 지속적인 피드백을 통해 개발자의 성장 지원
• 팀별 기술적 난제를 해결하도록 지원하며, 문제 해결 능력을 강화
• 프로젝트 일정 및 품질 관리를 통해 목표 달성을 위한 체계적인 진행을 도모
성과 및 기여
• 멘토링 프로그램을 통해 교육생들의 실무 능력을 향상시키고, 향후 취업 가능성을 높임
• 팀원 간의 협업과 소통을 강화하여 프로젝트 완수율을 높이고, 팀워크를 증진

트러블 슈팅 케이스 :
제일 큰 트러블슈팅은 라이브에서 영상공유를 할 때 거든? 이게 뭐가 문제였냐면, @https://pusher.com/ 여기 사이트에 있는 푸셔라는 라이브러리를 실시간 통신하기 위해 사용했는데, 이제 사용자가 영상이나 강의를 공유하게 되면, 이 푸셔를 통해서 나머지 사용자가 영상이나 강의에 해당하는 타입의 메시지를 받고, 링크를 같이 받고, 이 링크를 VIDEO 태그를 통해 각자 틀어주거든? 그리고 공유다 보니까 서로의 플레이 시간이 같아야되잖아? 그니까 같은걸 봐야하잖아. 근데, 이게 아무래도 소켓통신이고, 라이브러리 자체가 느린건지 통신이 보내고 도착하는데 1초 내의 시간( 0.2~0.5초 ) 정도의 시간이 걸리더라구? 그래서 멈출때마다 이 시간이 점점 쌓여서, 실제 멈춘 사람과 플레이 시간의 차이가 점점 커지더라구. 특히 동시다발적으로 재생과 일시정지를 했을때 오는 메시지의 순서도 그렇고 점점 꼬이게 되더라구.. 어떤 느낌인지 알겠어? 네명이서 영상공유를 같이 보는데, 각각 0.1초 간격으로 재생과 일시정지를 누른다고 했을때, 소켓통신이 0.2초에서 0.5초가 걸리니까 메시지가 중복해서 쌓이게 되고, 재생과 일시정지가 계솏 발생하고.. 그 사이 딜레이도 점차 서로 쌓이게 되어서, 결과적으로 다 다른 플레이 시간대를 보게 되는거지.
처음에는, 한 명만 이 영상을 재생/일시정지 하게끔 했는데 이것도 결국 소켓통신에서의 딜레이가 생기기 마련이잖아? 그래서 다른 회사(디스코드, ..)들은 영상공유를 어떻게 하는지 봤는데, 그런 회사들은 딜레이가 생기면 시간이 지날수록 점점 서로 맞춰지더라구? 아주 고급기술같은데 어떤 알고리즘으로 돌아가는지 예측도 못하겠어서, 컨퍼런스도 힘들었어. 이것만 이렇게 몇주~달 단위로 파다가, 결국에 내가 생각해낸게, 우리가 AGORA 스트리밍 서비스를 사용해서 라이브를 운영하고있잖아? 여기서 아고라의 클라이언트 유저는 임의로 키를 주고 추가를 할 수 있는데, 여기에 비디오 스트림이 들어가거든? 이게 없으면 그 유저의 비디오가 안뜨는거고...근데 여기에 카메라 비디오 스트림 말고, 실제 영상의 스트림을 넣으면 어떻게 될까? 싶어서 영상의 스트림을 타입을 계속 바꿔가면서 넣었는데 실행이 되는거야. 그래서 이 아고라의 한국지사 기술팀에게 문의를 했고, 실제로 비디오 형태를 넣어도 문제가 없다는걸 확인 받았고, 이 비디오의 재생/일시정지를 특정 펑션과 메소드를 사용해서 모든 사용자들이 이 임시(가짜)유저의 비디오 컨트롤을 가능하게 했고, 그 결과 모든 사람들이 끊김 없이 실시간으로 영상 공유가 가능하게 됐어. 
이건 강의 플랫폼 사이트에서, 강의가 서로 다르게 보이면 안된다는 생각과 끈질긴 기술연구와 노력덕분에 성공한 트러블슈팅 케이스같아! 이걸로 만들어줄래?

프로젝트 내용
- 깃허브의 파일들을 전부 가져온 후에, 해당 파일들에 해킹 위험성, 코드의 위험성처럼 코드를 분석하고, 코드가 보안상의 이슈나 문제가 없는지를
체크한다. 이 과정에서의 코드 검사는 LLM인 LLama3를 활용한다. 그 외의 깃허브 아이디 연동이나 파일연동과 관련된 라이브러리를 사용한다. 분석 완료된 코드를
저장할 수 있는데, 레포지토리별로 저장할 수 있도록 한다. 그리고 레포지토리별로 코드 검사 결과를 저장할 수 있도록 한다. 이게 메인 기능이고,
다른 웹사이트(보안관련된 이슈 사이트)에서 웹 크롤링을 통해서, 기사를 긁어와서 각종 해킹/보안 이슈를 모아놓은 사이트(여기선 분류나 필터, 일반적인 게시판에 필요한 각가지 기능이나 ux 구현)
등이 있다. 즉, 로그인(깃허브) 기능, 코드 검사기능, 웹크롤링을 통한 게시판, 게시판의 게시글 스크랩 기능등이 있는 프로젝트이다.

필자는 여기서 3개의 팀을 관리 했고, 실제 트러블 슈팅 같은 경우에 큰 경우는 puppeteer를 사용해서 웹크롤링을 통해서 기사를 긁어오는 경우가 있었는데, 
제대로 못 긁어오는..그런 이슈가 있었다. 푸피터 기능 동작에 관한 내용이였고, 도와줌으로써 해결이 되긴 했다. 또 라마의 프롬프트를 해결하기도 했고,
nextjs의 폴더링 구조를 같이 고민해주기도 했었다!


SKILLS.
Frontend
JavaScript
jQuery
TypeScript
React
React Native
Next.js
Redux
Redux Toolkit
Recoil
React Query
Zustand
TailwindCSS
SCSS
CSS Module
Styled-Components
Backend
Node.js
Express
MongoDB
Mongoose
MySQL
GraphQL
Supabase
Testing & Documentation
Jest
React Testing Library
Storybook
Deployment & Monitoring
Vercel
Sentry
Google Analytics
Development Tools
Git
GitHub
SourceTree
Zeplin
Figma
npm
yarn
pnpm
Additional Technologies
OpenAI
DHTMLX
Chart.js
Agora RTC




# 코딩 컨벤션

코딩 컨벤션은 읽고, 관리하기 쉬운 코드를 작성하기 위한 일종의 코딩 스타일 규약입니다.
아래 나오는 내용들은 저희가 사용하는 코딩 컨벤션이고, 아웃풋을 추출할 때 해당 코딩 컨벤션을 잘 지켜주세요.

내가 코드를 만들어달라고 할때는, 아래의 규칙을 일단 지켜줘

1) 타입스크립트 최적화 -> 타입 명시화나 인터페이스, 타입 등, 추론을 최적화해서 구체적으로 작성법
2) 성능 최적화 -> useCallback, useMemo, useEffect 등 성능 최적화 함수 사용 -> 여러 개의 useState를 하나의 객체로 
통합 하는등의 상태 업데이트 등, 모든 면에서 최적화를 생각해서 작성해줘.
3) 코드 구조 개선 -> 각종 varient를 상수로 분리하거나, JSDoc을 사용해서 컴포넌트와 인터페이스에 대한 문서화, 또 불필요한
Import나 코드를 없애는 등의 전문적이고 깔끔한 코드의 구조를 생각해줘
4) 스타일링 최적화 -> 인라인 스타일과 클래스네임을 분리하여 가독성을 향상시키고, 동적 스타일은 useMemo를 사용해서 최적화해줘.
5) 접근성 개선 -> aria-label과 aria-live 속성 추가, 헤더 역할을 하는 요소에 role="heading" 추가, 클릭 가능한 요소에 role="button" 추가
6) 상수 관리 -> 매직 넘버 제거 및 상수화, 애니메이션 관련 값들을 중앙 집중화, 애니메이션 관련 값들을 중앙 집중화
7) Tailwind CSS 사용 시 주의사항 -> Tailwind CSS의 JIT 모드에서는 동적으로 생성된 클래스가 사전에 정의되어 있어야 하므로, 
상수로 선언된 값을 사용하여 스타일을 적용하는 방식은 피하고, 직접 Tailwind CSS 유틸리티 클래스를 사용하는 것을 지향한다.

## 외부 라이브러리

라이브러리를 설치할 경우에는 Package Manager를 pnpm을 기반으로 사용합니다.

## 폴더링

라우터별 폴더링 방식을 차용합니다.

- 라우터를 기능별로 폴더링합니다.
- 기능 별로 나누어진 폴더에서 페이지들의 폴더를 각각 생성한 후에 해당 위치에 레이아웃 파일 및 공통 파일을 넣습니다.
  예) /src/app/graph/page.tsx, /src/app/graph/components, /src/app/graph/styles
- 프로젝트 전체에 필요한 컴포넌트나 styles, util, lib, hooks 파일은 src 폴더 최상단에 위치합니다.
  예) /src/app, /src/components, /src/hooks, /src/lib
- 프로젝트 전체에 사용되는 공통 컴포넌트는 /src/components/common에 위치합니다.
- 라이브러리 관련 컴포넌트 및 함수는 /src/lib 폴더에 위치합니다.
- API 호출 관련 함수나 외부 서비스와의 통신을 담당하는 코드/데이터 패칭 로직은 /src/services 폴더에 위치합니다.
- 여러 곳에서 재사용 가능한 유틸리티 함수/날짜 포맷팅, 수학 연산 등의 헬퍼 함수 혹은 공통으로 사용되는 상수나 타입을 /src/utils 폴더에 위치합니다.

## 타입스크립트

- type과 interface를 명명할 때 Pascal Case를 사용합니다.
- 객체 형태는 Interface를 사용하고 그 외는 type을 사용합니다.

## 스타일링

스타일링은 Tailwind을 사용합니다.

- 클래스 순서는 레이아웃 -> 타이포그래피 -> 시각적 스타일 -> 기타 순으로 정렬합니다.
  예) class="flex items-center p-4 text-lg font-bold text-blue-500 hover:bg-gray-100"
- 반응형 클래스 순서는 아래 예시와 같습니다.
  예) class="w-full sm:w-1/2 md:w-1/3 lg:w-1/4"
- 상태 관련 클래스(hover, focus 등)는 일반 클래스 뒤에 배치합니다.
  예) class="text-white bg-blue-500 hover:bg-blue-600 focus:ring-2"
- 자주 사용하는 클래스 조합은 @apply 디렉티브를 사용하여 커스텀 클래스를 만듭니다.
  예) @layer component { .btn-primary { @apply px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600;} }
- 관련된 클래스들은 괄호로 그룹화하여 가독성을 향상시킵니다.
  예) class="(flex items-center justify-between) (p-4 m-2) (text-lg font-bold)"
- 조건부 클래스 적용을 위해 clsx나 classnames 같은 유틸리티 함수를 사용합니다.
  예) <div className={clsx('base-class'), isActive && 'active_class', isDisabled && 'disabled-class')} />

## 네이밍 컨벤션

- 불필요한 줄임말을 사용하지 않고 명확한 네이밍을 사용합니다.
- 변수는 기본적으로 카멜 케이스를 사용합니다.
  예) isActive, myProfile
- 상수는 영문 대문자 스네이크 케이스를 사용합니다.
  예) SNAKE_CASE, TOTAL_MEMBER, LIMIT
- 데이터가 boolean 타입일 경우 prefix로 is를 사용합니다.
  예) isLoggedIn, isOpen
- 변수에 할당되는 값이 배열일 경우 복수형 이름을 사용합니다
  예) users, members
- 컴포넌트 네이밍은 파스칼 케이스를 사용합니다.
  예) function FuncName(){...}
- 이벤트 핸들러는 props인 경우 on + 이벤트명, 함수인 경우 handle + 함수명(이벤트)을 사용합니다.
  예) onSubmit, handleForm
- 컴포넌트의 property는 camelCase를 사용합니다.
  예) <Foo userName="1234" phoneNumber="14444" />

## 컴포넌트 순서

1. 변수를 가장 위에 선언합니다.
2. 변수 중에서도 state를 상위에 둡니다.
3. 그 다음 handler 등 함수를 선언합니다.
4. 그 다음 useEffect를 선언합니다.
5. 마지막으로 return을 선언합니다.

## 주석 사용

주석을 사용하는 경우 JSDoc 문법을 사용합니다.
특히, 컴포넌트 및 훅 단위에는 반드시 파라미터에 대한 주석을 작성해주어야 합니다.

- 변수 작성법

```tsx
/**
 * 과일 타입
 * @type {'Apple' | 'Banana' | 'Orange'}
 */
const fruit = 'Apple';
```

- 함수 작성법

```tsx
/**
 * 토스트 메세지 띄우는 함수
 * @param {object} props
 * @param {string} props.message 토스트 메세지
 */
const onInitToast = ({ message }) => {
  ...
}
```

- 컴포넌트 및 훅 단위에는 반드시 파라미터에 대한 주석을 작성합니다.

```tsx
/**
 * 컴포넌트명
 * @param {object} props
 * @param {string} props.foo foo에 대한 설명
 * @param {number} props.bar bar에 대한 설명
 */
const Component = ({ foo, bar }) => {
  return <div> ... </div>;
};

export default Component;
```

- 유틸 및 api 단위에는 함수별로 주석을 작성합니다.

```tsx
/**
 * 덧셈 함수
 * @param {number} a
 * @param {number} b
 */
const add = (a, b) => a + b;

/**
 * 곱셈 함수
 * @param {number} a
 * @param {number} b
 */
const multiply = (a, b) => a * b;
```
